{"version":3,"sources":["../../src/lib/Toc.js"],"names":["re","getBuffer","buffer","title","methodTitle","code","innerCode","table","linkTitle","methodTitleRe","codeRe","innerCodeRe","tableRe","linkTitleRe","cutTitle","cutLinkTitle","cutCode","cutMethodTitle","cutInnerCode","cutTable","map","marker","rule","insertTitle","insertLinkTitle","insertMethodTitle","insertInnerCode","insertTable","rs","Replaceable","regExp","replacement","stripComments","typedefMdRule","typeRule","c","Catchment","end","b","promise","Toc","Transform","constructor","config","skipLevelOne","level","_transform","enc","next","res","superRe","RegExp","source","exec","t","link","length","bb","slice","filter","a","join","trim","json","args","JSON","parse","s","name","type","shortType","tt","fullTitle","replace","err","heading","p","repeat","Math","max","push","getToc","stream","pipe"],"mappings":"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","sourcesContent":["import { Transform } from 'stream'\nimport Catchment from 'catchment'\nimport { getLink } from '.'\nimport { methodTitleRe, replaceTitle } from './rules/method-title'\nimport { codeRe, commentRule as stripComments, innerCodeRe, linkTitleRe } from './rules'\nimport { Replaceable } from 'restream'\nimport { makeInitialRule, makeRule, makeMarkers } from './markers'\nimport { tableRe } from './rules/table'\nimport typeRule from './rules/type'\nimport typedefMdRule from './rules/typedef-md'\n\nconst re = /(?:^|\\n) *(#+) *((?:(?!\\n)[\\s\\S])+)\\n/\n\nconst getBuffer = async (buffer) => {\n  const {\n    title, methodTitle, code, innerCode, table, linkTitle,\n  } = makeMarkers({\n    title: /^ *#+.+/gm,\n    methodTitle: methodTitleRe,\n    code: codeRe,\n    innerCode: innerCodeRe,\n    table: tableRe,\n    linkTitle: linkTitleRe,\n  })\n\n  const [cutTitle, cutLinkTitle, cutCode, cutMethodTitle, cutInnerCode, cutTable] =\n    [title, linkTitle, code, methodTitle, innerCode, table].map((marker) => {\n      const rule = makeInitialRule(marker)\n      return rule\n    })\n  const [insertTitle, insertLinkTitle, insertMethodTitle, insertInnerCode, insertTable] =\n    [title, linkTitle, methodTitle, innerCode, table].map((marker) => {\n      const rule = makeRule(marker)\n      return rule\n    })\n\n  const rs = new Replaceable([\n    cutTitle,\n    cutInnerCode,\n    cutLinkTitle,\n    {\n      re: innerCode.regExp,\n      replacement() {\n        return ''\n      },\n    },\n    cutTable,\n    cutMethodTitle,\n    cutCode,\n    stripComments,\n    typedefMdRule,\n    typeRule,\n    insertMethodTitle,\n    insertTable,\n    insertLinkTitle,\n    insertInnerCode,\n    insertTitle,\n  ])\n  const c = new Catchment({ rs })\n  rs.end(buffer)\n  const b = await c.promise\n  return b\n}\n\nexport default class Toc extends Transform {\n  /**\n   * A transform stream which will extract the titles in the markdown document and transform them into a markdown nested list with links.\n   * @param {Config} [config] Configuration object.\n   * @param {boolean} [config.skipLevelOne=true] Don't use the first title in the TOC (default `true`).\n   */\n  constructor(config = {}) {\n    const {\n      skipLevelOne = true,\n    } = config\n    super()\n    this.skipLevelOne = skipLevelOne\n    this.level = 0\n  }\n  async _transform(buffer, enc, next) {\n    let res\n\n    const b = await getBuffer(buffer)\n    // create a single regex otherwise titles will always come before method titles\n    const superRe = new RegExp(`(?:${re.source})|(?:${methodTitleRe.source})|(?:${linkTitleRe.source})`, 'g')\n    while ((res = superRe.exec(b)) !== null) {\n      let t\n      let level\n      let link\n      if (res[8] && res[9]) {\n        t = res[8]\n        level = res[9] != 't' ? res[9].length : this.level + 1\n        link = getLink(t)\n      } else if (res[1]) { // normal title regex\n        const [, { length }, title] = res\n        this.level = length\n        if (this.skipLevelOne && this.level == 1) continue\n        t = title\n        link = getLink(title)\n      } else { // the method title regex\n        try {\n          const { length } = res[3]\n          this.level = length\n          if (this.skipLevelOne && this.level == 1) continue\n          const bb = res.slice(4, 6).filter(a => a).join(' ').trim()\n          const json = res[7] || '[]'\n          const args = JSON.parse(json)\n          const s = args.map(([name, type, shortType]) => {\n            let tt\n            if (shortType) tt = shortType\n            else if (typeof type == 'string') tt = type\n            else tt = 'object'\n            return `${name}: ${tt}`\n          })\n          const fullTitle = replaceTitle(...res.slice(3)).replace(/^#+ +/, '')\n          link = getLink(fullTitle)\n          t = `\\`${bb}(${s.join(', ')})${res[6] ? `: ${res[6]}` : ''}\\``\n        } catch (err) {\n          // ok\n          continue\n        }\n      }\n      const heading = `[${t}](#${link})`\n      let s\n      if (!level) level = this.level\n      level = this.skipLevelOne ? level - 1 : level\n      if (level == 1) {\n        s = `- ${heading}`\n      } else {\n        const p = '  '.repeat(Math.max(level - 1, 0))\n        s = `${p}* ${heading}`\n      }\n      this.push(s)\n      this.push('\\n')\n    }\n    next()\n  }\n}\n\nexport const getToc = async (stream) => {\n  const rs = new Toc()\n  stream.pipe(rs)\n  const { promise } = new Catchment({ rs })\n  const t = await promise\n  return t.trim()\n}\n\n/**\n * @typedef {Object} Config\n * @property {boolean} [skipLevelOne=true] Don't use the first title in the TOC (default `true`).\n */\n"],"file":"Toc.js"}