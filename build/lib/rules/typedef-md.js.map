{"version":3,"sources":["../../../src/lib/rules/typedef-md.js"],"names":["LOG","typedefMdRe","typedefMdRule","re","replacement","match","location","typeName","xml","root","length","Error","content","Root","types","typedefs","map","props","type","Type","fromXML","imports","name","from","desc","noToc","import","ft","filter","emit","mdt","_","a","toMarkdown","join","e","message"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;;;AAEA,MAAMA,MAAM,oBAAS,KAAT,CAAZ;AAEO,MAAMC,cAAc,gCAApB;AAEP;;;;;;;;AAMA,MAAMC,gBAAgB;AACpBC,MAAIF,WADgB;;AAEpB,QAAMG,WAAN,CAAkBC,KAAlB,EAAyBC,QAAzB,EAAmCC,QAAnC,EAA6C;AAC3C,QAAI;AACF,YAAMC,MAAM,MAAM,aAAKF,QAAL,CAAlB;AACA,YAAMG,OAAO,oBAAY,OAAZ,EAAqBD,GAArB,CAAb;AACA,UAAI,CAACC,KAAKC,MAAV,EAAkB,MAAM,IAAIC,KAAJ,CAAU,6CAAV,CAAN;AAElB,YAAM,CAAC;AAAEC,iBAASC;AAAX,OAAD,IAAsBJ,IAA5B;AACA,YAAMK,QAAQ,oBAAY,MAAZ,EAAoBD,IAApB,CAAd;AACA,YAAME,WAAWD,MACdE,GADc,CACV,CAAC;AAAEJ,eAAF;AAAWK;AAAX,OAAD,KAAwB;AAC3B,cAAMC,OAAO,IAAIC,aAAJ,EAAb;AACAD,aAAKE,OAAL,CAAaR,OAAb,EAAsBK,KAAtB;AACA,eAAOC,IAAP;AACD,OALc,CAAjB;AAOA,YAAMG,UAAU,oBAAY,QAAZ,EAAsBR,IAAtB,EACbG,GADa,CACT,CAAC;AAAEC,eAAO;AAAEK,cAAF;AAAQC,cAAR;AAAcC;AAAd;AAAT,OAAD,KAAqC;AACxC,cAAMN,OAAO,IAAIC,aAAJ,EAAb;AACAD,aAAKE,OAAL,CAAa,EAAb,EAAiB;AACfE,cADe;AAEfJ,gBAAO,WAAUK,IAAK,MAAKD,IAAK,EAFjB;AAGfG,iBAAO,IAHQ;AAIfC,kBAAQ,IAJO;AAKfF;AALe,SAAjB;AAOA,eAAON,IAAP;AACD,OAXa,CAAhB;AAaA,YAAMS,KAAK,CAAC,GAAGN,OAAJ,EAAa,GAAGN,QAAhB,EACRa,MADQ,CACD,CAAC;AAAEN;AAAF,OAAD,KAAc;AACpB,YAAIf,QAAJ,EAAc,OAAOe,QAAQf,QAAf;AACd,eAAO,IAAP;AACD,OAJQ,CAAX;AAMA,WAAKsB,IAAL,CAAU,OAAV,EAAmBF,GAAGX,GAAH,CAAO,CAAC;AAAEM;AAAF,OAAD,KAAcA,IAArB,CAAnB;AAEA,UAAIf,YAAY,CAACoB,GAAGjB,MAApB,EAA4B,MAAM,IAAIC,KAAJ,CAAW,QAAOJ,QAAS,aAA3B,CAAN;AAE5B,YAAMuB,MAAMH,GACTX,GADS,CACL,CAACE,IAAD,EAAOa,CAAP,EAAUC,CAAV,KAAgB;AACnB,eAAOd,KAAKe,UAAL,CAAgBD,CAAhB,CAAP;AACD,OAHS,CAAZ;AAKA,aAAOF,IAAII,IAAJ,CAAS,MAAT,CAAP;AACD,KA3CD,CA2CE,OAAOC,CAAP,EAAU;AACVnC,UAAI,uCAAJ,EAA6CM,QAA7C,EAAuD6B,EAAEC,OAAzD;AACA,aAAO/B,KAAP;AACD;AACF;;AAlDmB,CAAtB;AAqDA;;;;eAIeH,a","sourcesContent":["import { debuglog } from 'util'\nimport extractTags from 'rexml'\nimport { read } from '..'\nimport Type from '../typedef/Type'\n\nconst LOG = debuglog('doc')\n\nexport const typedefMdRe = /^%TYPEDEF (.+?)(?: (.+?))?%$/mg\n\n/**\n * This rule is used to used to parse a typedefs XML file and place the\n * definition of a type into documentation.\n * @todo Cache extracted types from XML files.\n * @type {{re: RegExp, replacement: AsyncReplacer}}\n */\nconst typedefMdRule = {\n  re: typedefMdRe,\n  async replacement(match, location, typeName) {\n    try {\n      const xml = await read(location)\n      const root = extractTags('types', xml)\n      if (!root.length) throw new Error('XML file should contain root types element.')\n\n      const [{ content: Root }] = root\n      const types = extractTags('type', Root)\n      const typedefs = types\n        .map(({ content, props }) => {\n          const type = new Type()\n          type.fromXML(content, props)\n          return type\n        })\n\n      const imports = extractTags('import', Root)\n        .map(({ props: { name, from, desc } }) => {\n          const type = new Type()\n          type.fromXML('', {\n            name,\n            type: `import('${from}').${name}`,\n            noToc: true,\n            import: true,\n            desc,\n          })\n          return type\n        })\n\n      const ft = [...imports, ...typedefs]\n        .filter(({ name }) => {\n          if (typeName) return name == typeName\n          return true\n        })\n\n      this.emit('types', ft.map(({ name }) => name))\n\n      if (typeName && !ft.length) throw new Error(`Type ${typeName} not found.`)\n\n      const mdt = ft\n        .map((type, _, a) => {\n          return type.toMarkdown(a)\n        })\n\n      return mdt.join('\\n\\n')\n    } catch (e) {\n      LOG('(%s) Could not process typedef-md: %s', location, e.message)\n      return match\n    }\n  },\n}\n\n/**\n * @typedef {import('restream').AsyncReplacer} AsyncReplacer\n */\n\nexport default typedefMdRule\n"],"file":"typedef-md.js"}