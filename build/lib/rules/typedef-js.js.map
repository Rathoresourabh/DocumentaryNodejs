{"version":3,"sources":["../../../src/lib/rules/typedef-js.js"],"names":["LOG","typedefJsRe","makeBlock","s","typedefRule","re","replacement","match","location","xml","root","length","Error","content","Root","types","typedefs","map","props","tt","Type","fromXML","emit","ts","toTypedef","is","name","from","iss","join","tss","importsAndTypes","b","typedef","e","message"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;;;AAEA,MAAMA,MAAM,oBAAS,KAAT,CAAZ;AAEO,MAAMC,cAAc,yDAApB,C,CAGP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAEA,MAAMC,YAAaC,CAAD,IAAO;AACvB,SAAQ;EACRA,CAAE;;CADF;AAID,CALD;AAOA;;;;;;AAIA,MAAMC,cAAc;AAClBC,MAAIJ,WADc;;AAElB,QAAMK,WAAN,CAAkBC,KAAlB,EAAyBC,QAAzB,EAAmC;AACjC,QAAI;AACFR,UAAI,0BAAJ,EAAgCQ,QAAhC;AACA,YAAMC,MAAM,MAAM,YAAKD,QAAL,CAAlB;AACA,YAAME,OAAO,oBAAY,OAAZ,EAAqBD,GAArB,CAAb;AACA,UAAI,CAACC,KAAKC,MAAV,EAAkB,MAAM,IAAIC,KAAJ,CAAU,6CAAV,CAAN;AAElB,YAAM,CAAC;AAAEC,iBAASC;AAAX,OAAD,IAAsBJ,IAA5B;AAEA,YAAMK,QAAQ,oBAAY,MAAZ,EAAoBD,IAApB,CAAd;AACA,YAAME,WAAWD,MAAME,GAAN,CAAU,CAAC;AAAEJ,eAAF;AAAWK;AAAX,OAAD,KAAwB;AACjD,cAAMC,KAAK,IAAIC,aAAJ,EAAX;AACAD,WAAGE,OAAH,CAAWR,OAAX,EAAoBK,KAApB;AACA,eAAOC,EAAP;AACD,OAJgB,CAAjB;AAMA,WAAKG,IAAL,CAAU,OAAV,EAAmBN,QAAnB,EAfE,CAe2B;;AAE7B,YAAMO,KAAKP,SACRC,GADQ,CACJE,MAAMA,GAAGK,SAAH,EADF,CAAX,CAjBE,CAoBF;;AACA,YAAMC,KAAK,oBAAY,QAAZ,EAAsBX,IAAtB,EACRG,GADQ,CACJ,CAAC;AAAEC,eAAO;AAAEQ,cAAF;AAAQC;AAAR;AAAT,OAAD,KAAgC,wBAAuBA,IAAK,MAAKD,IAAK,KAAIA,IAAK,EAD3E,CAAX;AAGA,YAAME,MAAMH,GAAGI,IAAH,CAAQ,IAAR,CAAZ;AACA,YAAMC,MAAMP,GAAGM,IAAH,CAAQ,QAAR,CAAZ;AACA,YAAME,kBAAmB,GAAEN,GAAGd,MAAH,GAAa,GAAEiB,GAAI,QAAnB,GAA6B,EAAG,GAAEE,GAAI,EAAjE;AAEA,YAAME,IAAI9B,UAAU6B,eAAV,CAAV;AACA,YAAME,UAAW,kBAAiBzB,QAAS,QAAOwB,CAAE,EAApD;AACA,aAAOC,OAAP;AACD,KA/BD,CA+BE,OAAOC,CAAP,EAAU;AACVlC,UAAI,uCAAJ,EAA6CQ,QAA7C,EAAuD0B,EAAEC,OAAzD;AACA,aAAO5B,KAAP;AACD;AACF;;AAtCiB,CAApB;eAyCeH,W","sourcesContent":["import { debuglog } from 'util'\nimport extractTags from 'rexml'\nimport { read } from '..'\nimport Type from '../typedef/Type'\n\nconst LOG = debuglog('doc')\n\nexport const typedefJsRe = /^\\/\\* documentary (.+?) \\*\\/\\n(?:([^\\n][\\s\\S]+?\\n))?$/mg\n\n\n// const makePropsDesc = (props) => {\n//   return ''\n//   if (!props.length) return ''\n//   const l = props.map(({ props: { name, opt } }) => {\n//     const n = opt ? `[${name}]` : name\n//     return `\\`${n}\\``\n//   })\n//   return `Has properties: ${l.join(', ')}.`\n// }\n\nconst makeBlock = (s) => {\n  return `/**\n${s}\n */\n`\n}\n\n/**\n * @typedef {import('restream').AsyncReplacer} AsyncReplacer\n * @type {{re: RegExp, replacement: AsyncReplacer}}\n */\nconst typedefRule = {\n  re: typedefJsRe,\n  async replacement(match, location) {\n    try {\n      LOG('Detected type marker: %s', location)\n      const xml = await read(location)\n      const root = extractTags('types', xml)\n      if (!root.length) throw new Error('XML file should contain root types element.')\n\n      const [{ content: Root }] = root\n\n      const types = extractTags('type', Root)\n      const typedefs = types.map(({ content, props }) => {\n        const tt = new Type()\n        tt.fromXML(content, props)\n        return tt\n      })\n\n      this.emit('types', typedefs) // remember types for js-replace-stream\n\n      const ts = typedefs\n        .map(tt => tt.toTypedef())\n\n      // imports\n      const is = extractTags('import', Root)\n        .map(({ props: { name, from } }) => ` * @typedef {import('${from}').${name}} ${name}`)\n\n      const iss = is.join('\\n')\n      const tss = ts.join('\\n *\\n')\n      const importsAndTypes = `${is.length ? `${iss}\\n *\\n` : ''}${tss}`\n\n      const b = makeBlock(importsAndTypes)\n      const typedef = `/* documentary ${location} */\\n${b}`\n      return typedef\n    } catch (e) {\n      LOG('(%s) Could not process typedef-js: %s', location, e.message)\n      return match\n    }\n  },\n}\n\nexport default typedefRule\n"],"file":"typedef-js.js"}